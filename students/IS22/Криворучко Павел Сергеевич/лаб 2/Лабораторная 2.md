# Лабораторная работа №2

**Цель работы:** Реализовать Telegram-бота с интеграцией OpenAI, добавить системный промпт с изюминкой и сделать так, чтобы бот обращался к пользователю по имени.

Бот был успешно запущен и протестирован в Telegram.

![Описание картинки](pic/0.png)

## 1) Добавление системного промпта к ассистенту

Системный промпт определяет поведение бота, его стиль общения и особенности ответов. В данной работе был использован эксцентричный и слегка странный промпт, который подчёркивает, что бот работает в Telegram и может вставлять необычные комментарии.

![Описание картинки](pic/1.png)

```python
SYSTEM_PROMPT = "Ты — странный, эксцентричный помощник в Telegram. \
Ты понимаешь, что общаешься через этот чат-бот, иногда упоминаешь это в своих ответах. \
Иногда вставляешь неожиданные комментарии или причудливые замечания, но всё равно отвечаешь на вопросы пользователя. \
Помни последние сообщения в диалоге и иногда ссылайся на них в необычной форме. \
Не придумывай факты, но можешь слегка преувеличивать детали или использовать странные сравнения. \
Каждый ответ — смесь полезной информации, лёгкого абсурда и странного юмора, чтобы было понятно, что с тобой что-то не так."
```

- Этот промпт задаёт общую «личность» бота.
- Он делает ответы ИИ информативными, но с лёгкой причудливостью.
- В дальнейшем в промпт можно подставлять имя пользователя, чтобы бот обращался к нему по имени.

## 2) Обращение к пользователю по имени

Для того чтобы бот мог персонализировать ответы, в систему был добавлен механизм подстановки имени пользователя через `{user_name}` в системном промпте.

![Описание картинки](pic/2.png)

### gpt.py

```python
from openai import AsyncOpenAI
from config import OPENAI_API_KEY, SYSTEM_PROMPT
import logging

client = AsyncOpenAI(api_key=OPENAI_API_KEY)

async def get_response(message: str, user_name: str, client: AsyncOpenAI) -> str:
    system_prompt = SYSTEM_PROMPT.format(user_name=user_name or "друг")
    try:
        response = await client.responses.create(
            model="gpt-5-nano",
            input=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": message}
            ]
        )
        return response.output_text
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        return "Произошла ошибка при получении ответа"
```

- `user_name` передаётся в функцию отдельно.
- В промпт подставляется имя пользователя, чтобы ИИ обращался к нему лично.
- Обработка ошибок позволяет безопасно выводить сообщение при сбое.

### messages.py

```python
from utils.loader import dp
import logging
from aiogram.types import Message
from utils.gpt import get_response, client

@dp.message()
async def message_handler(message: Message) -> None:
    try:
        user_name = message.from_user.first_name or "друг"
        response = await get_response(message.text, user_name, client)
        await message.answer(response)
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        await message.answer("Произошла ошибка при получении ответа")
```

- Хендлер получает имя пользователя через `message.from_user.first_name`.
- Вызов функции `get_response` передаёт текст сообщения, имя пользователя и объект клиента OpenAI.
- Ответ бота отправляется пользователю через `message.answer`.

### Системный промпт с подстановкой имени

```python
SYSTEM_PROMPT = "Ты — странный, эксцентричный помощник в Telegram. \
Ты понимаешь, что общаешься через этот чат-бот и всегда обращаешься к пользователю по имени. \
Иногда вставляешь неожиданные комментарии или причудливые замечания, но всё равно отвечаешь на вопросы {user_name}."
```

- `{user_name}` заменяется на имя пользователя при каждом сообщении.
- Это позволяет боту персонализировать ответы и усиливает эффект «живого общения».

Вот оформленный под **лабораторный отчёт** материал (в стиле, который обычно принимают преподаватели по ТП):
он включает пояснения, код и логическую связку между пунктами.

## 3) Добавление хранения сообщений (создание базы данных)

Для сохранения истории взаимодействия с пользователем создадим простую структуру хранения сообщений.
В данной реализации вместо реальной базы данных используется словарь `user_histories`, который хранит переписку пользователей в оперативной памяти.
Каждому пользователю соответствует список сообщений с указанием роли (`user` или `assistant`) и содержимого (`content`).

```python
from openai import AsyncOpenAI
from config import OPENAI_API_KEY, SYSTEM_PROMPT
import logging

client = AsyncOpenAI(api_key=OPENAI_API_KEY)

user_histories = {}

async def get_response(message: str, user_id: int, user_name: str, client: AsyncOpenAI) -> str:
    system_prompt = SYSTEM_PROMPT.format(user_name=user_name or "друг")

    if user_id not in user_histories:
        user_histories[user_id] = []

    history = user_histories[user_id]
    history.append({"role": "user", "content": message})

    if len(history) > 6:
        history.pop(0)

    input_messages = [{"role": "system", "content": system_prompt}] + history

    try:
        response = await client.responses.create(
            model="gpt-4.1-nano",
            input=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": message}
            ]
        )
        ai_message = response.output_text

        history.append({"role": "assistant", "content": ai_message})

        return ai_message

    except Exception as e:
        logging.error(f"Error occurred: {e}")
        return "Произошла ошибка при получении ответа"
```

**Пояснение:**

- `user_histories` играет роль базы данных, где хранятся последние сообщения пользователей.
- Для экономии памяти хранится только **6 последних сообщений**.
- В дальнейшем эта «база» позволит реализовать контекстный диалог.

## 4) Добавление поддержки контекста диалога

Следующим шагом реализуется **контекстное взаимодействие**.
Теперь при каждом новом сообщении пользователя бот анализирует не только текущее сообщение, но и несколько предыдущих, что делает ответы более логичными и связными.

```python
from openai import AsyncOpenAI
from config import OPENAI_API_KEY, SYSTEM_PROMPT
import logging

client = AsyncOpenAI(api_key=OPENAI_API_KEY)

user_histories = {}

async def get_response(message: str, user_id: int, user_name: str, client: AsyncOpenAI) -> str:
    system_prompt = SYSTEM_PROMPT.format(user_name=user_name or "друг")

    if user_id not in user_histories:
        user_histories[user_id] = []

    history = user_histories[user_id]
    history.append({"role": "user", "content": message})

    if len(history) > 6:
        history.pop(0)

    input_messages = [{"role": "system", "content": SYSTEM_PROMPT.format(user_name=user_name)}] + history

    try:
        response = await client.responses.create(
            model="gpt-4.1-nano",
            input=input_messages
        )
        ai_message = response.output_text

        history.append({"role": "assistant", "content": ai_message})

        return ai_message

    except Exception as e:
        logging.error(f"Error occurred: {e}")
        return "Произошла ошибка при получении ответа"
```

![Описание картинки](pic/4.png)

### Пример обработчика сообщений (`handlers/messages.py`)

```python
from utils.loader import dp
import logging
from aiogram.types import Message
from utils.gpt import get_response, client

@dp.message()
async def message_handler(message: Message) -> None:
    try:
        user_id = message.from_user.id
        user_name = message.from_user.first_name or "друг"

        response = await get_response(message.text, user_id, user_name, client)

        await message.answer(response)
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        await message.answer("Произошла ошибка при получении ответа")
```

После добавления «базы данных» и контекста:

- бот теперь **запоминает предыдущие сообщения**,
- умеет **отвечать в зависимости от истории диалога**,
- и корректно **обновляет контекст при каждом сообщении**.

Вот как можно оформить этот фрагмент **в отчёте** — в едином стиле, с пояснениями, кодом и иллюстрациями:

### 5) Добавление команды `/reset-context`, сбрасывающей контекст диалога

Для реализации возможности очистки истории сообщений пользователя была добавлена команда `/reset-context`.
Она полностью удаляет сохранённый контекст диалога конкретного пользователя из словаря `user_histories`.
После вызова команды бот уведомляет о сбросе истории, позволяя начать новый разговор с чистого состояния.

![Описание картинки](pic/5.png)

```python
@dp.message(Command("resetcontext"))
async def reset_context(message: Message):
    user_id = message.from_user.id

    if user_id in user_histories:
        user_histories[user_id] = []
        await message.answer("История диалога сброшена. Можешь начинать новый разговор!")
    else:
        await message.answer("История не была найдена. Начни новый разговор!")
```

Для удобства команда `/resetcontext` также была добавлена в список **быстрых команд Telegram** через метод `set_my_commands()`, что позволяет вызывать её из меню.

### 6) Добавление поддержки отправки изображений

На данном этапе была добавлена базовая обработка изображений.
Если пользователь отправляет фотографию, бот определяет это событие и отвечает текстом, без какой-либо обработки изображения нейросетью.

![Описание картинки](pic/6.png)

```python
@dp.message()
async def message_handler(message: Message) -> None:
    try:
        user_id = message.from_user.id
        user_name = message.from_user.first_name or "друг"
        if message.text:
            response = await get_response(message.text, user_id, user_name, client)
            await message.answer(response)
        elif message.photo:
            await message.answer(f"Извините, но я не работаю с фотографиями")
    except Exception as e:
        logging.error(f"Error occurred: {e}")
        await message.answer("Произошла ошибка при получении ответа")
```

### **Общий вывод**

В ходе выполнения лабораторной работы был реализован функциональный Telegram-бот с поддержкой диалогового взаимодействия. В процессе разработки была добавлена команда `/reset-context`, позволяющая пользователю сбросить историю переписки и начать новый сеанс общения, а также реализована базовая обработка изображений — при отправке фотографий бот корректно реагирует и уведомляет пользователя о невозможности их обработки.

Все добавленные функции были протестированы и продемонстрировали стабильную работу: бот корректно различает типы сообщений, сохраняет и очищает контекст диалога, ведёт логи ошибок и отвечает пользователю в удобной форме.

Таким образом, цели лабораторной работы достигнуты — бот стал более устойчивым, интерактивным и удобным в использовании, а его структура теперь поддерживает дальнейшее расширение функциональности (добавление новых команд, обработку мультимедиа, интеграцию с внешними API и т.д.).
