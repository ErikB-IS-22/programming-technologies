Цель: получение навыков работы с библиотекой Aiogram, связка API OpenAI и написанного бота.
Перед началом разработки бота был получен токен бота. Для этого в BotFather и выполнить следующие действия: Start >> Open >> Create new bot (рис. 1). Далее было создано имя бота и его адрес, при этом адрес обязательно должен кончаться на bot

Рисунок 1 – Создание нового бота в BotFather
Далее был получен токен бота (рис. 2). Была создана команда /start. Для этого в меню бота во вкладке Commands были заполнены обязательные поля (рис. 3).
 
Рисунок 2 – Получение токена бота в BotFather
 
Рисунок 3 – Создание команды в BotFather
После создания бота и получения токена был создан файл .env куда были добавлены API-ключ с предыдущей лабораторной работы и токен бота. Файл был добавлен в .gitignore. По аналогии с предыдущей лабораторной работой было создано виртуальное окружение (рис. 4) и были установлены соответствующие библиотеки.
 
 
Рисунок 4 – Создание виртуального окружения
Был создан файл config.py, в который будут добавляться переменные окружения (рис.5).
 
Рисунок 5 – Файл config.py
Далее были созданы папки handlers и utils. В первой будут храниться обработчики событий, во второй - вспомогательные функции. В обоих были созданы файлы __init__.py, которые необходимы для работы папок как пакетов. В папке utils были созданы файлы loader.py (рис. 6) и gpt.py (рис. 7). В файле loader.py были импортированы библиотеки, загружены переменные окружения и созданы бот и диспетчер. Также был установлен HTML-парсинг, чтобы можно было использовать HTML-теги в сообщениях. В файл gpt.py была перенесена функция get_response из предыдущей лабораторной работы
 
Рисунок 6 – Файл loader.py
 
Рисунок 7 – Файл gpt.py
Также в папке __init__.py был добавлен код, который позволяет импортировать модули из папки utils в другие модули (рис. 8).
 
Рисунок 8 – Файл __init__.py в папке utils
В папке handlers были созданы файлы commands.py (рис. 9) и messages.py (рис. 10). В первом будут храниться обработчики команд, во втором - обработчики сообщений. Код commands.py выполняет функцию базовой команды /start. В случае успешного выполнения, бот отправляет пользователю сообщение с приветствием. В случае ошибки, бот отправляет в логгер сообщение об ошибке. Код messages.py выполняет функцию обработки сообщений. В случае успешного выполнения, бот отправляет пользователю ответ от ассистента. В случае ошибки, бот отправляет пользователю сообщение об ошибке. 
 
Рисунок 9 – Файл commands.py
 
Рисунок 10 – Файл messages.py
Также в папке __init__.py был добавлен код, который позволяет импортировать модули из папки handlers в другие модули (рис. 11).
 
Рисунок 11 – Файл __init__.py в папке handlers
Далее был создан файл main.py (рис. 12) в котором Диспатчер запускает процесс поллинга - цикл, который слушает входящие сообщения и обрабатывает их. Конструкция if name == "main" позволяет запустить код только в случае, если файл запускается напрямую, а не импортируется в другой файл. Внутри устанавливается уровень логирования и запускается процесс поллинга посредством библиотеки asyncio. После чего бот был запущен с помощью команды python main.py. Видно, что бот функционирует успешно (рис. 13).
 
Рисунок 12 – Файл main.py
 
Рисунок 13 – Проверка работы бота
Для выполнения заданий необходимо было добавить системный промпт к боту. По сути, данное задание уже было готово, так как в коде, который был перенесён из предыдущей лабораторной работы, уже присутствовал системный промпт. Далее необходимо было сделать так, чтобы бот знал имя пользователя и при ответе обращался к нему по имени. Для этого системный промпт был изменён на "You are a helpful assistant. Always address the user by name before replying. The person you answer to is {user}", где user – это имя пользователя (message.from_user.full_name) (рис. 14). Чтобы исправить ошибки, связанные с тем, что нейросеть возвращает текст с форматированием, которые Telegram не может распарсить, было отключено форматирование при отправке с помощью parse_mode=None (рис. 15).
 
Рисунок 14 – Добавление и изменение системного промпта, чтобы бот обращался по имени
 
Рисунок 15 – Исправление ошибок, связанных с форматированием
Также необходимо было добавить хранение сообщений в базе данных, добавить поддержку контекста диалога с помощью базы данных и добавить команду, которая будет сбрасывать контекст диалога. Для этого был создан файл database.py, куда была перенесена таблица базы данных сообщений из предыдущей лабораторной работы. Код в gpt.py был отредактирован так, чтобы сообщения сохранялись в базу данных (рис. 16). Для сброса контекста диалога была добавлена новая команда и новый обработчик команды в commands.py (Command("resetcontext")) (рис. 17) Видно, что сообщения действительно сохраняются в базу данных, а контекст диалога сохраняется (рис. 18).
 
Рисунок 16 – Отредактированный файл gpt.py для сохранения сообщений в базу данных
 
Рисунок 17 – Добавление команды для сброса контекста диалога
 
 
Рисунок 18 – Проверка контекта диалога
Последним заданием было добавление поддержки отправки изображений, чтобы после отправления изображения бот текстом отвечал "Вы отправили картинку!". Для этого в messages.py был обработчик изображений (F.photo) (рис. 19). Видно, что бот выполняет функцию как требуется (рис. 20).
 
Рисунок 19 – Обработчик изображений
 
Рисунок 20 – Проверка обработчика изображений

