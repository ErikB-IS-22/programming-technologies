# Лабораторная работа №2: Простейший чат-бот в Telegram

## Цель работы

Цель лабораторной работы — получение навыков работы с библиотекой Aiogram, связка API OpenAI и написанного бота.

## Инструменты и настройки

- **Язык программирования**: Python.
- **Библиотеки**:
  - `openai` — для работы с API.
  - `dotenv` — для загрузки переменных окружения (например, API-ключ).
  - `aiogram` - для работы с Telegram API, предоставляет удобный асинхронный интерфейс для создания ботов, обработки сообщений, команд и взаимодействия с пользователем.
  

## Реализованные задачи

В коде были реализованы следующие задачи:

1. **Добавление к ассистенту системный промпт**:
    
    ```
    from config import api_key, prompt

    response = await client.responses.create(
    model="gpt-4.1-nano",
    input=[{"role": "system", "content": prompt}] + [{"role": "user", "content": f"Пользователя зовут {user_name}"}] + dialog_history_actual,
    )
    ```

    Переменная system_prompt извлекается из файла .env с помощью os.getenv("SYSTEM_PROMPT"). Системный промпт помогает задавать общий контекст для общения с моделью, например, как она должна вести себя.

    **Результат работы:**

    Бот генерирует ответы, используя системный контекст.

    ![Системный промт](./Screenshots/систем%20промпт.png)


2. **Добавление функции обращения к пользователю по имени**:
    Для того чтобы бот знал имя пользователя, используем атрибут message.from_user.full_name
    ```
    response = await get_response(message.text, message.from_user.id, message.from_user.full_name, client)
    ```
    и передаем в функцию запроса к ChatGPT
    ```
    ... + [{"role": "user", "content": f"Пользователя зовут {user_name}"}] + ...
    ```
    
    ![Обращение к пользователю](./Screenshots/знает%20имя%20п.png)
   

3. **Добавление хранения сообщений и поддержку контекста диалога**:
    ```
    dialog_history = {}

    async def get_response(message: str, user_id: str, user_name: str, client: AsyncOpenAI) -> str:
        dialog_history_actual = dialog_history.get(user_id, [])

        dialog_history_actual.append({"role": "user", "content": message})

        if len(dialog_history_actual) > 50:
            dialog_history_actual.pop(0)

        try:
            response = await client.responses.create(
                model="gpt-4.1-nano",
                input=[{"role": "system", "content": prompt}] + [{"role": "user", "content": f"Пользователя зовут {user_name}"}] + dialog_history_actual,
            )

            dialog_history_actual.append({"role": "assistant", "content": response.output_text})

            dialog_history[user_id] = dialog_history_actual

            return response.output_text
        except Exception as e:
            logging.error(f"Error occurred: {e}")
            return "Произошла ошибка при получении ответа"

    ```
   Для того, чтобы ИИ помнил контекст общения с пользователем, была реализована система ведения истории диалога. Контекст переписки ограничивался 50 последними сообщениями. У каждого пользователя свой отдельный список. 

   Для упрощения задачи и быстрого прототипирования я решил использовать список, ну или если конкретно - словарь внутри Python для хранения истории сообщений, что позволяет эффективно управлять данными без необходимости подключения базы данных, обеспечивая при этом простоту реализации и ускорение процесса разработки, что идеально подходит для учебного прототипа.

4. **Добавление команды /resetcontext, которая будет сбрасывать контекст диалога**
    ```
    @dp.message(Command("resetcontext"))
    async def reset_context(message: Message):
        user_id = message.from_user.id  # Получаем user_id из сообщения

        if user_id in dialog_history:
            dialog_history[user_id] = []  # Очищаем историю для данного пользователя
            await message.answer("История диалога сброшена. Можешь начинать новый разговор!")
        else:
            await message.answer("История не была найдена. Начни новый разговор!")
    ```
    Для реализации команды `/resetcontext`, которая сбрасывает контекст диалога, я создал обработчик для этой команды, который проверяет, есть ли сохраненная история для конкретного пользователя, используя его уникальный `user_id`. Когда пользователь отправляет команду `/resetcontext`, я извлекаю его user_id из сообщения с помощью `message.from_user.id`. Затем, проверяя, существует ли запись этого `user_id` в словаре `dialog_history`, я очищаю соответствующую историю, присваивая пустой список, что фактически сбрасывает контекст диалога для этого пользователя. После этого отправляется сообщение, подтверждающее, что история была сброшена и можно начать новый разговор. Если история для этого пользователя еще не была сохранена, бот сообщает, что история не найдена и предлагает начать новый разговор с чистого листа.

    ![Ресет контекст до реализации](./Screenshots/До%20ресет%20команды.png)

    ![Ресет контекст после реализации](./Screenshots/После%20ресет%20команды.png)


4. **Добавление поддержки отправки изображений (без их обработки нейронкой).**
    ```
    else:
            await message.answer(f"Спасибо, что отправили  {str(message.content_type)[12:]}, но я работаю только с обычными сообщениями)")
    ```

    Для обработки сообщений, отличных от текста (например, изображений, видео и других медиа), я добавил проверку типа сообщения с помощью атрибута `content_type` объекта `Message`. В коде я использую условие `if message.text`, которое проверяет, является ли сообщение текстовым. Если сообщение не является текстом, то с помощью `else` блоки проверяется, что было отправлено, и бот отвечает пользователю в зависимости от типа содержимого.

    Если отправленное сообщение является изображением, видео, аудио или другим медиа, бот использует атрибут `message.content_type` для того, чтобы определить тип контента. Я применил срез для строки `message.content_type`, чтобы красиво вывести тип отправленного контента в сообщении для пользователя, например, "Спасибо, что отправили фото", если было отправлено изображение.


    ![Отправка изображения](./Screenshots/Реакция%20на%20изобаржение.png)

    ![Отправка видео](./Screenshots/Реакция%20на%20видео.png)



